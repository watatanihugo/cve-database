DROP SCHEMA IF EXISTS vulnerabilities_db;
CREATE SCHEMA vulnerabilities_db;
USE vulnerabilities_db;


CREATE TABLE vulnerable_appliances (
	ID INT AUTO_INCREMENT PRIMARY KEY,
    Name VARCHAR(255) NOT NULL,
    Medium VARCHAR(50) NOT NULL,
    OS VARCHAR(100),
    Version VARCHAR(50),
	INDEX idx_Name (Name)
);

CREATE TABLE CVE_ID (
    ID VARCHAR(50) PRIMARY KEY UNIQUE NOT NULL,
    Name VARCHAR(255) NOT NULL,
    FOREIGN KEY (Name) REFERENCES vulnerable_appliances(Name) ON UPDATE CASCADE
);

CREATE TABLE Description (
    ID VARCHAR(50) PRIMARY KEY UNIQUE NOT NULL,
    text_description VARCHAR(255) NOT NULL,
    recorded_references VARCHAR(255),
    recorded_breaches INTEGER,
    FOREIGN KEY (ID) REFERENCES CVE_ID(ID) ON UPDATE CASCADE
);

CREATE TABLE Proof_Of_Exploit (
	ID VARCHAR(50) PRIMARY KEY UNIQUE NOT NULL,
	Exploit_demo VARCHAR(255) NOT NULL,
	Author VARCHAR(50) NOT NULL,
	Code_implementation VARCHAR(255), 	
    FOREIGN KEY (ID) REFERENCES CVE_ID(ID) ON UPDATE CASCADE
);

CREATE TABLE CVE_Scores (
    ID VARCHAR(50) PRIMARY KEY UNIQUE NOT NULL,
    Base_Score DECIMAL(3,1),
    Method_of_entry VARCHAR(255),
    Attack_Vector_v3 VARCHAR(255),
    FOREIGN KEY (ID) REFERENCES CVE_ID(ID) ON UPDATE CASCADE
);
CREATE INDEX idx_Attack_Vector_v3 ON CVE_Scores (Attack_Vector_v3);
CREATE TABLE Sub_Scores (
    ID VARCHAR(50) PRIMARY KEY NOT NULL,
    Attack_Vector_v3 VARCHAR(255),
    Attack_Complexity CHAR(32),
    Privilege_Required CHAR(32),
    User_Interaction CHAR(32),
    Scope CHAR(32),
    Confidentiality CHAR(32),
    Integrity CHAR(32),
    Availability CHAR(32),
    FOREIGN KEY (ID) REFERENCES CVE_ID(ID) ON UPDATE CASCADE
);

DELIMITER //

CREATE PROCEDURE ShowCVEs()
BEGIN
    SELECT c.ID, s.Base_Score, s.Attack_Vector_v3, LEFT(d.text_description, 95) AS truncated_description
    FROM CVE_ID c 
    JOIN CVE_Scores s ON c.ID = s.ID 
    JOIN Description d ON c.ID = d.ID;
END //

DELIMITER ;


